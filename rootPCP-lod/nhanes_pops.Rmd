---
title: "PCP-LOD: NHANES POPs"
author: "Lizzy Gibson"
date: "3/16/2021"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(NMF)
library(janitor)
library(ggcorrplot)
library(ggfortify)  
library(gridExtra)
library(factoextra)
library(knitr)
library(haven)
library(rlist)
library(Matrix)
library(matconv)
library(patchwork)
library(mvtnorm)
library(reshape2)
library(GGally)
library(grDevices)
library(gplots)
library(pcpr)
library(here)
library(PCPhelpers)
options(scipen = 999)
```

## NHANES

* **Info:** https://wwwn.cdc.gov/Nchs/Nhanes/2001-2002/L28POC_B.htm  

* CDC imputes values \<LOD as LOD/sqrt(2).  
* Here, if comment code = "below detectable limit", set value to -1.  
* All values are measured in blood and lipid-adjusted.  
* Make matrix of LODs to use in LOD PCP. 

```{r, data, include=FALSE}
all_nhanes = read_sas(here("./Data/studypop_lod.sas7bdat")) %>% 
  clean_names()

# Variables that end in "la" are the POP concentrations
conc_nhanes = all_nhanes %>% dplyr::select(grep("la$", colnames(.)))
# Variables that end in "lc" are the <LOD labels
orig_label_nhanes = all_nhanes %>% dplyr::select(grep("lc$", colnames(.)))

# same order
all(str_sub(colnames(conc_nhanes), 4, 6) == str_sub(colnames(label_nhanes), 4, 6))

# 1 == <LOD, change to -1
# 0 == >LOD, change to 1
label_nhanes = orig_label_nhanes
label_nhanes[label_nhanes == 1] = -1
label_nhanes[label_nhanes == 0] = 1

# element-wise multiply to set conc <LOD to -1
nhanes = (conc_nhanes * label_nhanes) %>% as_tibble()
nhanes[nhanes < 0] = -1
```

```{r, rename_func, include=FALSE}
pop_label_groups <- function(names) {
 names = case_when(grepl("(^D|d$|TCDD)", names) ~ "Dioxins", 
           grepl("(^F|f$)", names) ~ "Furans",
           grepl("(126|169|hxc|pcb|HXC|PCBPCB)", names) ~ "Non-Ortho PCBs",
           grepl("(105|118|156|157|167|198)", names) ~ "Mono-Ortho PCBs",
           TRUE ~ "Non-Dioxin-like PCBs")
 names = as_factor(names)
 names
}

pop_rename = function(name) {
  name = str_to_upper(name)
  name = case_when(grepl('074', name) ~ 'PCB 74',
                   grepl('099', name) ~ 'PCB 99',
                   grepl('118', name) ~ 'PCB 118',
                   grepl('138', name) ~ 'PCB 138',
                   grepl('153', name) ~ 'PCB 153',
                   grepl('170', name) ~ 'PCB 170',
                   grepl('180', name) ~ 'PCB 180',
                   grepl('187', name) ~ 'PCB 187',
                   grepl('194', name) ~ 'PCB 194',
                   grepl('D03', name) ~   '1,2,3,6,7,8-hxcdd',
                   grepl('D05', name) ~ '1,2,3,4,6,7,8-hpcdd',
                   grepl('D07', name) ~'1,2,3,4,6,7,8,9-ocdd',
                   grepl('F03', name) ~     '2,3,4,7,8-pncdf',
                   grepl('F04', name) ~   '1,2,3,4,7,8-hxcdf',
                   grepl('F05', name) ~   '1,2,3,6,7,8-hxcdf',
                   grepl('F08', name) ~ '1,2,3,4,6,7,8-hxcdf',
                   grepl('(hxc|HXC)', name) ~ 'PCB 169',
                   grepl('(LBDPCBLC|PCBPCB|LBXPCBLA)', name) ~ 'PCB 126', 
                   grepl("105", name) ~ "PCB 105",    
                   grepl("156", name) ~ "PCB 156", 
                   grepl("157", name) ~ "PCB 157", 
                   grepl("167", name) ~ "PCB 167",
                   grepl("D01", name) ~ "Dioxin 1",  
                   grepl("D04", name) ~ "Dioxin 4",   
                   grepl("F01", name) ~  "Furan 1",
                   grepl("F02", name) ~  "Furan 2",  
                   grepl("F04", name) ~  "Furan 4",  
                   grepl("F06", name) ~  "Furan 6", 
                   grepl("F07", name) ~  "Furan 7",   
                   grepl("TCD", name) ~     "TCDD",
                   grepl("189", name) ~  "PCB 189",  
                   grepl("196", name) ~  "PCB 196", 
                   grepl("199", name) ~  "PCB 199", 
                   grepl("D02", name) ~ "Dioxin 2", 
                   grepl("F09", name) ~  "Furan 9"  )
         name = as_factor(name)
         name
}

col_rename = function(pops) {
      colnames(pops) <- str_sub(colnames(pops), 1, 6)
      colnames(pops) <- str_replace(colnames(pops), "(lbxd|lbdd)", "D")
      colnames(pops) <- str_replace(colnames(pops), "(lbxf|lbdf)", "F")
      colnames(pops) <- str_replace(colnames(pops), "tcd", "TCDD")
      colnames(pops) <- str_replace(colnames(pops), "(lbx|lbd)", "PCB")
      if ("pops$PCBpcb" %in% colnames(pops)) {
      pops = pops %>% rename(PCB169 = PCBhxc, PCB126 = PCBpcb)}
      colnames(pops) <- str_to_upper(colnames(pops))
      return(pops)
      }
```

```{r, prop}
# this takes proportion detected
# Some values were NA, no result, but not <LOD
# so go back to original labels
# 1 == <LOD
# 0 == >LOD
# ignore NA
prop <- function (x) {1-(sum(x, na.rm = TRUE)/length(x[!is.na(x)]))}
```

```{r}
orig_label_nhanes %>% 
            summarize_all(prop) %>% 
  pivot_longer(lbd074lc:lbdf09lc) %>%
  mutate(name = str_to_upper(name),
         name = pop_rename(name),
         name = fct_reorder(name, value)) %>% 
  ggplot(aes(x = name, y = value)) +
  geom_segment( aes(x=name, xend=name, y=0, yend=value), color="grey") +
  geom_point( color="orange", size=2) +
  theme_light() +
  theme(panel.grid.major.x = element_blank(),
        panel.border = element_blank(),
       axis.ticks.x = element_blank(),
       axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "% > LOD", n = "")

detected = orig_label_nhanes %>%
            summarize_all(prop) %>% 
  pivot_longer(lbd074lc:lbdf09lc) %>%
  mutate(name = str_to_upper(name),
         name = pop_rename(name),
         name = fct_reorder(name, value)) %>% rename(Chemicals = name, Detected = value) %>% 
  arrange(desc(Detected))
```

```{r, process, include=FALSE}
# x is a proportion
# take all variables > x and preprocess them
# scale them and save their lods
process_pops = function(x) {
  # Select pops with detection above a certain limit
  props <- orig_label_nhanes %>% summarize_all(prop)
  lod_names  = props %>% select_if(~. > x) %>% names()
  conc_names = lod_names %>% str_sub(., 4, 6) %>% str_c("lbx", ., "la")  

  pops <- nhanes %>% dplyr::select(all_of(conc_names)) %>% na.omit(.)
  pops = col_rename(pops)
  
  # Make matrix of 0/1
  lods <- orig_label_nhanes %>% 
          select(lod_names) %>% 
          na.omit()
  
  # Matrix of all values (with CDC imputed values)
  imputed <- read_sas(here::here("./Data/studypop_lod.sas7bdat")) %>% 
              clean_names() %>% 
              select(all_of(conc_names)) %>% 
              na.omit() %>% as.matrix()
  imputed = col_rename(imputed)
  
  # Element-wise multiplication by 1/0
  # Keep values <LOD
  # Values >LOD == 0
  # Multiply by sqrt(2) to get back LOD
  lod_matrix <- (lods * imputed) * sqrt(2)
  lod_matrix <- as.matrix(lod_matrix)
  lod_matrix <- col_rename(lod_matrix)
  #summary(lod_matrix)

  # Need to scale POPs because they have super different ranges. 
  # Need to get rid of values less than LOD to scale and then add them back.
  
  # make <LOD NA so they dont affect the scaling
  pops[pops < 0] <- NA

  # Get stand dev of values > LDO
  denoms = apply(pops, 2, function(a) sd(a, na.rm = T))
  pops_scaled = apply(pops, 2, function(a) a/sd(a, na.rm = T))
  
  # make <LOD negative again
  pops_scaled[is.na(pops_scaled)] <- -1
  pops_scaled = as.matrix(pops_scaled)

  # Also want to scale the LODS!
  # Scale lod matrix by stand dev of measurements
  lod_matrix <- lod_matrix/denoms

  # and scale imputed
  imputed = apply(imputed, 2, function(a) a/sd(a, na.rm = T))
  
  return(list(scaled_data = pops_scaled, lods = lod_matrix, sqrt2_data = imputed))
}
```

## 50% > LOD

```{r}
fifty_percent = process_pops(.5)

data_50  = as.matrix(fifty_percent$scaled_data)
delta_50 = fifty_percent$lods
imputed_50 = fifty_percent$sqrt2_data

#write_csv(as.data.frame(data_50), "./experiments/law_experiments/PCPhelpers/Data/nhanes_50.csv")
#write_csv(as.data.frame(delta_50), "./experiments/law_experiments/PCPhelpers/Data/nhanes_50_lods.csv")
```

```{r}
ggcorr(imputed_50, method = c("everything", "spearman"), limits = FALSE,
       label = TRUE, label_size = 3, label_alpha = TRUE,
       hjust = 0.85, size = 3, color = "grey50", layout.exp = 1) + 
  ggtitle("Persistent Organic Pollutants","NHANES 2001-2002")
```

## CV

```{r}
n = nrow(data_50)
p = ncol(data_50)

m = sqrt(p/2)
lam = 1/sqrt(n)

lambda <- c(seq(0, lam, length.out = 10)[-c(1,10)], seq(lam, 1, length.out = 5))
rank <- 1:10

grid.pop <- expand.grid(lambda = lambda, r = rank)
evals = ceiling(.07*nrow(grid.pop))

# noncvx_search <- bayes_search_cv(mat = data_50, 
#                                  pcp_func = root_pcp_noncvx_nonnegL_na_lod, 
#                                  grid_df = grid.pop,
#                                  init_evals = evals, bayes_evals = evals, 
#                                  cores = 2, runs = 5, LOD = delta_50, mu = sqrt(p/2))
# to_save = noncvx_search$formatted
# save(to_save, file = "./rootPCP-lod/nhanes_cv.rda")

# we can even continue the search by passing bayes the formatted results from the last one:
noncvx_search_re <- bayes_search_cv(mat = data_50, pcp_func = root_pcp_noncvx_nonnegL_na_lod, 
                                  grid_df = save2,
                                  init_evals = evals, bayes_evals = 1, 
                                  cores = 2, runs = 5, LOD = delta_50, mu = sqrt(p/2))
save_search = noncvx_search_re$formatted
# save(save_search, file = "./rootPCP-lod/nhanes_cv.rda")
load("./rootPCP-lod/nhanes_cv.rda")
save_search
```

```{r}
noncvx_search_re$formatted %>% arrange(desc(lambda))

noncvx_search_re$formatted %>%
  arrange(desc(value)) %>% 
  drop_na() %>% 
  arrange(desc(value))

noncvx_search_re$formatted %>%
  distinct() %>% 
  drop_na() %>% 
  mutate(opt = ifelse(value == min(value, na.rm = T), "X", "")) %>%
  mutate(lambda = as_factor(round(lambda, 4)),
         r = as_factor(r)) %>% 
  ggplot(aes(y = lambda, x = r)) +
  geom_tile(aes(fill = value)) +
  geom_text(aes(label=opt), color = "white") +
  scale_fill_viridis_c() +
  theme_test()
```

## PCP

```{r}
best.idx <- which.min(noncvx_search_re$formatted$value)
optimal.lambda <- noncvx_search_re$formatted$lambda[best.idx]
optimal.r <- noncvx_search_re$formatted$r[best.idx]
# above config did not converge

nextbest.idx <- which.min(noncvx_search_re$formatted$value[-best.idx])
nextoptimal.lambda <- noncvx_search_re$formatted$lambda[nextbest.idx]
nextoptimal.r <- noncvx_search_re$formatted$r[nextbest.idx]
# Converged in 13388 iterations.

pcp_out <- root_pcp_noncvx_nonnegL_na_lod(D = data_50, 
                                   lambda = nextoptimal.lambda, mu = m, 
                                   r = nextoptimal.r, LOD = delta_50,
                                           verbose = TRUE)
#save(pcp_out, file = "./rootPCP-lod/nhanes_pcp_out.rda")
#load("./rootPCP-lod/nhanes_pcp_out.rda")

save(pcp_out, file = "./rootPCP-lod/nhanes_pcp_out_take2.rda")
#load("./rootPCP-lod/nhanes_pcp_out.rda")

L = pcp_out$L
S = pcp_out$S
```

### Sparse Matrix

```{r}
sum(S == 0)/(nrow(S)*ncol(S))
sum(S < 0)/(nrow(S)*ncol(S))
sum(S < 0.0001)/(nrow(S)*ncol(S))

sparse_prop = props %>% 
  select_if(~. > 0.5) %>% 
  col_rename() %>% 
  mutate(which = "prop") %>% 
  bind_rows(., apply(S, 2, function(x) sum(x > 0.001)/length(x))) %>% 
  pivot_longer(1:21) %>% 
  pivot_wider(names_from = which,
              values_from = value) %>% 
  rename(dense = `NA`) %>% 
  arrange(dense)

sparse_prop %>% ggplot(aes(x = prop, y = dense)) + geom_point() + theme_test() +
  geom_smooth(se = F, method = "lm") +
  labs(x = "Proportion detected in original data", y = "Proportion non-zero in S matrix")

cor.test(sparse_prop$prop, sparse_prop$dense)
sparse_prop %>% 
  print(n=21)

plot_sparse <- S %>% as_tibble() %>%
  mutate(id = 1:nrow(.)) %>% 
  select(id, everything()) %>% 
  gather(key = exposure, value = value, -id) %>% 
  mutate(exposure = str_to_upper(exposure)) %>% 
  left_join(., props_50) %>% 
  mutate(exposure = pop_rename(exposure),
          tozero = ifelse(value < 0.001, 0, value))
# sparse event (0) vs non-sparse event (not zero)
# this treats negative as sparse event, too
```

```{r fig.width = 10}
props_50 %>% arrange((prop)) %>% print(n=21)

plot_sparse %>%
    mutate(exposure = fct_reorder(exposure, prop)) %>% 
  ggplot(aes(x = exposure, y = id)) +
  geom_tile(aes(fill = tozero)) +
  labs(x = "Exposure", y = "Participant", 
       title = "Sparse matrix of rare events", fill = "Magnitude") +
  theme_test() +
  scale_fill_viridis_b(breaks = c(0,0.00001,0.0001,12,16)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        legend.text = element_text(angle=45, hjust=1))
```

```{r}
above_mask = data_50 > 0
above_mask[above_mask == 0] = NA
below_mask = data_50 < 0
below_mask[below_mask == 0] = NA

sum(below_mask, na.rm = T) + sum(above_mask, na.rm = T)

S_above = S*above_mask
S_below = S*below_mask

sum(S_above == 0, na.rm = T)/sum(above_mask, na.rm = T)
sum(S_above < 0, na.rm = T)/sum(above_mask, na.rm = T)
sum(S_above < 0.001, na.rm = T)/sum(above_mask, na.rm = T)

sum(S_below == 0, na.rm = T)/sum(below_mask, na.rm = T)
sum(S_below < 0, na.rm = T)/sum(below_mask, na.rm = T)
sum(S_below < 0.0001, na.rm = T)/sum(below_mask, na.rm = T)

sum(S_below > 0.00001, na.rm = T)
```

### Patterns

```{r}
ggcorr(L, method = c("everything", "spearman"), limits = FALSE,
       label = TRUE, label_size = 3, label_alpha = TRUE,
       hjust = 0.85, size = 3, color = "grey50", layout.exp = 1) + ggtitle("Low Rank Matrix from LOD PCP")
```

## PCA 

### of low rank matrix

```{r}
# Default is scale = false but this is ok bc we scaled data to begin with
pcp_pca <- prcomp(L)

pcp_scores = pcp_pca$x

fviz_eig(pcp_pca, main = "PCA on Low Rank Matrix",
         xlab = "Principal components") 

# plot rotations (loadings) of chemicals on patterns in low rank matrix
pcp_plot = pcp_pca$rotation %>% 
  as_tibble() %>% 
  mutate(Chemicals = colnames(data_50)) %>% 
  select(Chemicals, PC1:PC4) %>% 
  gather(key = Component, value = Loadings, -Chemicals) %>%
  mutate(Group = pop_label_groups(Chemicals)) %>%
  arrange(Group) %>% 
  mutate(Chemicals = pop_rename(Chemicals),
         Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings, color = Group)) + geom_point() +
  geom_segment(aes(yend=0, xend = Chemicals)) +
  facet_wrap(.~Component, nrow = 1) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank()) + labs(title = "PCA on PCP L matrix")
```

### of full data data

```{r}
# data already scaled
pca_50 <- prcomp(imputed_50)

pca_scores = pca_50$x

fviz_eig(pca_50, main = "PCA on Original Matrix",
         xlab = "Principal components") 

pca_plot = 
  pca_50$rotation %>% 
  as_tibble() %>% 
  mutate(Chemicals = colnames(fifty_percent$sqrt2_data)) %>% 
  select(Chemicals, PC1:PC4) %>% 
  gather(key = Component, value = Loadings, -Chemicals) %>%
  mutate(Group = pop_label_groups(Chemicals)) %>% 
  arrange(Group) %>% 
  mutate(Chemicals = pop_rename(Chemicals),
        Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings, color = Group)) + geom_point() +
  geom_segment(aes(yend=0, xend = Chemicals)) +
  facet_wrap(.~Component, nrow = 1) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank()) + labs(title = "PCA on original data (LOD/sqrt2)")
```

### Viz

```{r}
#pdf("./Figures/pcp_pca.pdf", width = 12)
(pcp_plot + theme(axis.text.x = element_blank())) / (pca_plot + theme(legend.position = "none"))
#dev.off()
```

```{r}
PCP_PCA <- pcp_pca$sdev^2/sum(pcp_pca$sdev^2) *100
just_PCA <- pca_50$sdev^2/sum(pca_50$sdev^2) *100
round(cbind(Component = 1:21, PCP_PCA, just_PCA), 4) %>% kable()
```

### Scores

```{r}
norm(pca_scores - pcp_scores, "F")/norm(pca_scores, "F")
norm(pca_scores - pcp_scores, "F")/norm(pcp_scores, "F")

score_diff = pcp_scores - pca_scores

score_diff %>% 
  as_tibble() %>% 
  pivot_longer(1:21)


min(data_50[data_50 != -1])
min(L)
min(S)
```

## Relative error

```{r}
mask = data_50 != -1
data_above = data_50 * mask

L_above = L*mask
S_above = S*mask

norm(data_above-L_above, "F")/norm(data_above, "F")
norm(data_above-L_above-S_above, "F")/norm(data_above, "F")

pca_pred = pca_50$x %*% t(pca_50$rotation) + # un-center
           kronecker(matrix(1, nrow(imputed_50), 1), t(pca_50$center))
pca_pred_above = pca_pred*mask

norm(imputed_50 - pca_pred, "F")/norm(imputed_50, "F")

norm(data_above - pca_pred, "F")/norm(data_above, "F") # all 21 PC

pca_pred_4 = pca_50$x[,1:4] %*% t(pca_50$rotation)[1:4,] + # un-center
              kronecker(matrix(1, nrow(imputed_50), 1), t(pca_50$center))

norm(data_above - pca_pred_4, "F")/norm(data_above, "F") # first 4 PC
```

## NMF

### on L matrix

```{r}
sum(L<0)
L[L < 0] = 0
any(is.null(L))
any(is.na(L))

summary(L)
L[220:221,] # one row ALL zero

L_less = L[-221,]

L_nmf = nmf(L_less, 4, method = "lee", nrun = 100)

L_nmf_scores = basis(L_nmf)
```

```{r}
nmf_plot = 
  coef(L_nmf) %>% 
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "Chemicals") %>% 
  as_tibble() %>% 
  pivot_longer(V1:V4) %>% 
  mutate(Chemicals = pop_rename(Chemicals),
         Group     = pop_label_groups(Chemicals)) %>%
  arrange(Group) %>% 
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = value, color = Group)) + geom_point() +
  geom_segment(aes(yend=0, xend = Chemicals)) +
  facet_wrap(.~name, nrow=1) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank()) +
  labs(y = "Loadings", title = "NMF on PCP L matrix")
```

### on original data

#### choose rank

```{r}
nmf_1 = nmf(imputed_50, 1, method = "lee", nrun = 100)
nmf_2 = nmf(imputed_50, 2, method = "lee", nrun = 100)
nmf_3 = nmf(imputed_50, 3, method = "lee", nrun = 100)
nmf_4 = nmf(imputed_50, 4, method = "lee", nrun = 100)
nmf_5 = nmf(imputed_50, 5, method = "lee", nrun = 100)
nmf_6 = nmf(imputed_50, 6, method = "lee", nrun = 100)

get_bic <- function(patterns, fit){
  bic = sum((imputed_50 - (basis(fit)%*%coef(fit)))^2) + 
    (1/2)*(nrow(imputed_50) + ncol(imputed_50)) * patterns * log(nrow(imputed_50) * ncol(imputed_50))
  return(bic)
}

get_bic(1, nmf_1) # bic chooses 1
get_bic(2, nmf_2)
get_bic(3, nmf_3)
get_bic(4, nmf_4)
get_bic(5, nmf_5)
get_bic(6, nmf_6)

get_aic <- function(patterns, fit){
  aic = sum((imputed_50 - (basis(fit)%*%coef(fit)))^2) + 
        (nrow(imputed_50) + ncol(imputed_50)) * patterns
  return(aic)
}

get_aic(1, nmf_1)
get_aic(2, nmf_2)
get_aic(3, nmf_3) # AIC chooses 3
get_aic(4, nmf_4)
get_aic(5, nmf_5)
get_aic(6, nmf_6)
```

```{r}
apply(imputed_50, 2, sd)
nmf_out = nmf(imputed_50, 4, method = "lee", nrun = 100)

nmf_scores = basis(nmf_out)

plot_nmf_total = coef(nmf_out) %>% 
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "Chemicals") %>% 
  pivot_longer(V1:V4) %>% 
  mutate(name = case_when(name == "V1" ~ "V4",
                          name == "V2" ~ "V3",
                          name == "V3" ~ "V2",
                          name == "V4" ~ "V1"),
         Chemicals = pop_rename(Chemicals),
         Group = pop_label_groups(Chemicals)) %>%
  arrange(Group) %>% 
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = value, color = Group)) + geom_point() +
  geom_segment(aes(yend=0, xend = Chemicals)) +
  facet_wrap(.~name, nrow = 1) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank()) +
  labs(y = "Loadings", title = "NMF on original data (LOD/sqrt2)")
```

### Scores

```{r}
nmf_scores_less = nmf_scores[-221,]
cor(nmf_scores_less, L_nmf_scores)

norm(nmf_scores_less - L_nmf_scores, "F")/norm(nmf_scores_less, "F")
norm(nmf_scores_less - L_nmf_scores, "F")/norm(L_nmf_scores, "F")

```

### Viz

```{r}
#pdf("./Figures/pcp_nmf.pdf", width = 12)
(nmf_plot + theme(axis.text.x = element_blank(), legend.position = "none")) / plot_nmf_total
#dev.off()
```

```{r}




```

